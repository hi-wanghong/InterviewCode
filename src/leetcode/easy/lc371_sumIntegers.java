package leetcode.easy;


/**
 * https://leetcode-cn.com/problems/sum-of-two-integers/
 *
 * 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
 *
 * 示例 1:
 * 输入: a = 1, b = 2
 * 输出: 3
 * 示例 2:
 *
 * 输入: a = -2, b = 3
 * 输出: 1
 */
public class lc371_sumIntegers {

    /**
     * 题目说不能使用运算符 + 和 -，那么我们就要使用其他方式来替代这两个运算符的功能。
     * 【位运算中的加法】
     * 我们先来观察下位运算中的两数加法，其实来来回回就只有下面这四种：
     *
     * 0 + 0 = 0
     * 0 + 1 = 1
     * 1 + 0 = 1
     * 1 + 1 = 0（进位 1）
     * 仔细一看，这可不就是相同位为 0，不同位为 1 的异或运算结果嘛~
     *
     * 【异或和与运算操作】
     * 我们知道，在位运算操作中，异或的一个重要特性是无进位加法。我们来看一个例子：
     *
     * a = 5 = 0101
     * b = 4 = 0100
     *
     * a ^ b 如下：
     * 0 1 0 1
     * 0 1 0 0
     * -------
     * 0 0 0 1
     * a ^ b 得到了一个无进位加法结果（9相当于二进制的1001，则无进位的显示结果就是0001），
     * 如果要得到 a + b 的最终值，我们还要找到进位的数，把这二者相加。
     * 在位运算中，我们可以使用与操作获得进位：
     *
     * a = 5 = 0101
     * b = 4 = 0100
     * 
     * a & b 如下：
     * 0 1 0 1
     * 0 1 0 0
     * -------
     * 0 1 0 0
     * 由计算结果可见，0100 并不是我们想要的进位，1 + 1 所获得的进位应该要放置在它的更高位，即左侧位上，
     * 因此我们还要把 0100 左移一位，才是我们所要的进位结果。（相当于十进制的8）
     * 
     * 那么问题就容易了，总结一下：
     * 
     * 1. a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)
     * 2. 无进位加法使用异或运算计算得出
     * 3. 进位结果使用与运算和移位运算计算得出
     * 4. 循环此过程，直到进位为 0
     * (在一次取进位后，如何知道加进位时是否有连续进位？应用【当前进位数】与原数取&，故设置temp)
     * 连续进位的意思是说，在得到无进位加和进位结果进行"+"操作的时候可能又需要进位，则需要重复上述过程
     *
     * @param a
     * @param b
     * @return
     */
    public int getSum(int a, int b) {
        int temp, res, up = 0;

        res = a ^ b;    //异或取得无进位结果
        up = a & b;     //判断是否有进位

        while( up != 0){
            up = up << 1;   //进位的具体结果是up左移一位
            temp = res; //存储临时的res，因为可能这一步的计算还是有进位
            res ^= up;  //计算最终结果

            up &= temp; //当前进位和原数（是a、b ^出来的结果）取&判断是否还有进位，而最终的结果是上一步的res

        }

        return res;
    }


        public static void main(String[] args) {
        System.out.println(new lc371_sumIntegers().getSum(-2, 3));
    }
}
